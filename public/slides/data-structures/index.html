<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>CFSS: Computing for the Social Sciences</title><meta name=description content='<!DOCTYPE html> Data Structures class: center, middle, inverse, title-slide .title[ # Data Structures ] .author[ ### MACSS 30500 University of Chicago ] --- class: inverse, middle # R Base Data Structures <!-- notes: this is a new lecture that focuses on a general review of data structures from the original lecture ("vectors-and-iteration") I kept the vectors and lists here and I need to enlarge this lecture with more data structures I do not think I need all libraries listed there, double check also check this lecture corresponding pages on the syllabus this lecture does not have notes (content > notes) make sure to do that ahead of time to ensure things work! --> --- ### R Base Data Structures R data structures: * Vectors * Matrices * Lists * Data frames * Arrays These data structures can be organized by: - their dimensions (1d, 2d, or nd) - whether they are homogeneous (all contents must be of the same type, like atomic vectors and matrices) or heterogeneous (contents can be of different types, like lists and data frames) Please, review: * Lecture 2 (`introR_lecture`) to define, subset, and manipulate these data structures * Chapter 20 "Vectors" in R for Data Science --- ### R is fundamentally a vector-based program So far, we have been using predominantly data frames, which are very common when working with social science data. However, data frames are not actually the most fundamental type of object in R: **vectors are the ultimate building blocks of objects within R**. A matrix is made of vectors, a list is made of vectors (a list is still a vector in R but not an atomic one), data frames are made by lists, etc. Basically in R either something is a vector, or it&#39;s NULL... --- ### R is fundamentally a vector-based program <img src="https://r4ds.had.co.nz/diagrams/data-structures-overview.png" width="60%" style="display: block; margin: auto;" /> <!-- focus today is on atomic vectors and lists --> --- class: inverse, middle # Atomic vectors --- ### Types of atomic vectors Remember: **All values in an atomic vector must to be of the same type**. **Logical**: you have used it every time you use a conditional test or operation (e.g., when you filter a data frame) ```r logical_vector <- c("TRUE", "TRUE", "FALSE", "TRUE", "NA") ``` **Numeric**: can be integer or double (default) ```r integer_vector <- c("1", "5", "3", "4", "12423") double_vector <- c("4.2", "4", "6", "53.2") ``` **Character**: note you can use single or double quotations, you just need to be consistent ```r character_vector <- c("Scary", "&#39;1,2,3 ready!&#39;", "Halloween", &#39;10/31/2022&#39;) ``` --- ### Scalars In math a scalar is defined as a single real number. R has no concept of a scalar: **in R, a scalar is simply a vector of length 1** ```r # set up a vector x of length 10 (x <- sample(10)) ``` ``` ## [1] 10 6 5 4 1 8 2 7 9 3 ``` ```r # add 100 to x x + c(100, 100, 100, 100, 100, 100, 100, 100, 100, 100) ``` ``` ## [1] 110 106 105 104 101 108 102 107 109 103 ``` ```r # add 100 to x: the R way (vector recycling) x + 100 ``` ``` ## [1] 110 106 105 104 101 108 102 107 109 103 ``` <!-- The second way to add the numbers is more efficient but can also be dangerous...--> --- ### Vector Recycling When two vectors are involved in an operation, **R repeats the elements of the shorter vector to match the length of the longer vector**. This will work for any vector of any length. For example: ```r # x1 is sequence of numbers from 1 to 2 (x1 <- seq(from = 1, to = 2)) ``` ``` ## [1] 1 2 ``` ```r # x2 is a sequence of numbers from 1 to 10 (x2 <- seq(from = 1, to = 10)) ``` ``` ## [1] 1 2 3 4 5 6 7 8 9 10 ``` --- ### Vector Recycling If we add `x1` and `x2` together, R will do it, but the result might not be what we expect: ```r (x1 + x2) ``` ``` ## [1] 2 4 4 6 6 8 8 10 10 12 ``` The shorter vector, `x1`, is duplicated five times in order to match the length of the longer vector `x2.` This behavior is called **vector recycling** and happens automatically in R. You need to pay attention if this is what you intended to do. If not, extend the length of the shorter vector manually first, then add them up. Note, if the shorter vector is not a multiple of the longer one, R will print a warning message. --- ### Subsetting vectors: slicing To subset a vector we use the index location of its elements: ```r x <- c("one", "two", "three", "four", "five") ``` ``` # keep the first element x[1] # keep the first through third elements x[c(1, 2, 3)] # long way x[1:3] # shorter x[c(seq(1, 3))] # sequence x[-c(4:5)] # negative indexing (values that you do not want to keep) x[-c(4,5)] # negative indexing x[c(-1,2,3)] # error! do not mix negative and positive subscripts ``` --- ### Subset with a logical vector: conditional subsetting Sometimes, rather than slicing, like we did in the previous example, we want to keep certain values based of a **condition**. This is more similar to a filtering operation (vs. slicing) and it is a 2-step operation: 1. create a logical vector of TRUEs and FALSEs, that identifies for each of the elements in the original vector, which one we want to keep 2. apply that vector to the vector we want to subset --- ### Subset with a logical vector: conditional subsetting Given a vector `x`: ```r x <- c(NA, 10, 3, 5, 8, 1, NA) ``` We want to keep all the non-missing values in `x`. To find them we can use `is.na()`. This function outputs a logical vector of TRUEs and FALSEs. Notice the `!` reverts the output, so we get TRUE for non-missing and FALSE for missing values -- we want to keep the TRUEs: ```r !is.na(x) ``` ``` ## [1] FALSE TRUE TRUE TRUE TRUE TRUE FALSE ``` Then, we put the function into `[]` to apply it to our `x` vector. This says "keep all elements that are TRUE" in this vector: ```r x[!is.na(x)] ``` ``` ## [1] 10 3 5 8 1 ``` --- ### Subset with a logical vector: conditional subsetting This applies to any kind of conditional test. For example, given the same vector `x`: ```r x <- c(NA, 10, 3, 5, 8, 1, NA) ``` We might want to get all even or missing values of `x`. To do so, we first use modular division: ```r x %% 2 == 0 ``` ``` ## [1] NA TRUE FALSE FALSE TRUE FALSE NA ``` Then, we apply it to our vector `x`: ```r x[x %% 2 == 0] ``` ``` ## [1] NA 10 8 NA ``` --- class: inverse, middle # Lists --- ## Lists Lists are another type of vector, but they are not atomic vector. They differ from atomic vectors in two main ways: 1. They **store heterogeneous elements** (vs. all values in an atomic vector must be of the same type) 2. They **are structured differently** and are created with the `list()` function, not with the `c()` function. Notice the output is different than the output from an atomic vector: ```r x <- list(1, 2, 3) x ``` ``` ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ``` --- ## Lists structure List objects are structured as a list of **independent elements**. Use `str()` to see their structure: ```r x <- list(1, 2, 3) str(x) ``` ``` ## List of 3 ## $ : num 1 ## $ : num 2 ## $ : num 3 ``` Here we have a list of length 3, and each of the elements of this list is a numeric atomic vector of length 1. --- ## Lists elements Unlike atomic vectors, lists can contain **multiple data types**, and we can also name each of them: ```r x_named <- list(a = "abc", b = 2, c = c(1, 2, 3)) str(x_named) ``` ``` ## List of 3 ## $ a: chr "abc" ## $ b: num 2 ## $ c: num [1:3] 1 2 3 ``` Here we have a list of length 3, and each of the elements of this list is a different object: we have a character vector of length 1, one numeric vector of length 1, and one numeric vector of length 3. --- ## Nested lists You can also store lists inside a list: **nested list structure**. In this object `z` we have two lists: ```r z <- list(list(1, 2), list(3, 4)) str(z) ``` ``` ## List of 2 ## $ :List of 2 ## ..$ : num 1 ## ..$ : num 2 ## $ :List of 2 ## ..$ : num 3 ## ..$ : num 4 ``` This is often useful when you interact with API to get data from the web (frequently you get this type of nested list as output when you get data from API). --- ## Secret lists: data frames! Notice, we have been using lists extensively in the class. Each column of a data frame is a list: ```r str(gun_deaths) ``` ``` ## spc_tbl_ [100,798 × 10] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ id : num [1:100798] 1 2 3 4 5 6 7 8 9 10 ... ## $ year : num [1:100798] 2012 2012 2012 2012 2012 ... ## $ month : chr [1:100798] "Jan" "Jan" "Jan" "Feb" ... ## $ intent : chr [1:100798] "Suicide" "Suicide" "Suicide" "Suicide" ... ## $ police : num [1:100798] 0 0 0 0 0 0 0 0 0 0 ... ## $ sex : chr [1:100798] "M" "F" "M" "M" ... ## $ age : num [1:100798] 34 21 60 64 31 17 48 41 50 NA ... ## $ race : chr [1:100798] "Asian/Pacific Islander" "White" "White" "White" ... ## $ place : chr [1:100798] "Home" "Street" "Other specified" "Home" ... ## $ education: Factor w/ 4 levels "Less than HS",..: 4 3 4 4 2 1 2 2 3 NA ... ``` The only difference between data frames and actual lists is that the length of each list object in the data frame has to the same (a data frame is rectangular). --- ## Subsetting lists Lists have a more complex structure than vectors, thus subsetting them also requires more attention. .pull-left[ For example, `a` is a list that contains four elements: * a numeric vector * a character vector * a numeric vector * a list object which in turns contains two distinct numeric vectors (notice the space in the middle) ] .pull-right[ <img src="lists-subsetting-a-only.png" width="30%" style="display: block; margin: auto;" /> ] --- ## Subsetting lists <img src="https://r4ds.had.co.nz/diagrams/lists-subsetting.png" width="50%" style="display: block; margin: auto;" /> --- class: inverse, middle # Practice subsetting vectors and lists --- ## Acknowledgments The content of these slides is derived in part from Sabrina Nardin and Benjamin Soltoff’s “Computing for the Social Sciences” course materials, licensed under the CC BY NC 4.0 Creative Commons License. Any errors or oversights are mine alone.'><meta property="og:url" content="https://cfssmacss.netlify.app/slides/data-structures/"><meta property="og:site_name" content="CFSS: Computing for the Social Sciences"><meta property="og:title" content="CFSS: Computing for the Social Sciences"><meta property="og:description" content='<!DOCTYPE html> Data Structures class: center, middle, inverse, title-slide .title[ # Data Structures ] .author[ ### MACSS 30500 University of Chicago ] --- class: inverse, middle # R Base Data Structures <!-- notes: this is a new lecture that focuses on a general review of data structures from the original lecture ("vectors-and-iteration") I kept the vectors and lists here and I need to enlarge this lecture with more data structures I do not think I need all libraries listed there, double check also check this lecture corresponding pages on the syllabus this lecture does not have notes (content > notes) make sure to do that ahead of time to ensure things work! --> --- ### R Base Data Structures R data structures: * Vectors * Matrices * Lists * Data frames * Arrays These data structures can be organized by: - their dimensions (1d, 2d, or nd) - whether they are homogeneous (all contents must be of the same type, like atomic vectors and matrices) or heterogeneous (contents can be of different types, like lists and data frames) Please, review: * Lecture 2 (`introR_lecture`) to define, subset, and manipulate these data structures * Chapter 20 "Vectors" in R for Data Science --- ### R is fundamentally a vector-based program So far, we have been using predominantly data frames, which are very common when working with social science data. However, data frames are not actually the most fundamental type of object in R: **vectors are the ultimate building blocks of objects within R**. A matrix is made of vectors, a list is made of vectors (a list is still a vector in R but not an atomic one), data frames are made by lists, etc. Basically in R either something is a vector, or it&#39;s NULL... --- ### R is fundamentally a vector-based program <img src="https://r4ds.had.co.nz/diagrams/data-structures-overview.png" width="60%" style="display: block; margin: auto;" /> <!-- focus today is on atomic vectors and lists --> --- class: inverse, middle # Atomic vectors --- ### Types of atomic vectors Remember: **All values in an atomic vector must to be of the same type**. **Logical**: you have used it every time you use a conditional test or operation (e.g., when you filter a data frame) ```r logical_vector <- c("TRUE", "TRUE", "FALSE", "TRUE", "NA") ``` **Numeric**: can be integer or double (default) ```r integer_vector <- c("1", "5", "3", "4", "12423") double_vector <- c("4.2", "4", "6", "53.2") ``` **Character**: note you can use single or double quotations, you just need to be consistent ```r character_vector <- c("Scary", "&#39;1,2,3 ready!&#39;", "Halloween", &#39;10/31/2022&#39;) ``` --- ### Scalars In math a scalar is defined as a single real number. R has no concept of a scalar: **in R, a scalar is simply a vector of length 1** ```r # set up a vector x of length 10 (x <- sample(10)) ``` ``` ## [1] 10 6 5 4 1 8 2 7 9 3 ``` ```r # add 100 to x x + c(100, 100, 100, 100, 100, 100, 100, 100, 100, 100) ``` ``` ## [1] 110 106 105 104 101 108 102 107 109 103 ``` ```r # add 100 to x: the R way (vector recycling) x + 100 ``` ``` ## [1] 110 106 105 104 101 108 102 107 109 103 ``` <!-- The second way to add the numbers is more efficient but can also be dangerous...--> --- ### Vector Recycling When two vectors are involved in an operation, **R repeats the elements of the shorter vector to match the length of the longer vector**. This will work for any vector of any length. For example: ```r # x1 is sequence of numbers from 1 to 2 (x1 <- seq(from = 1, to = 2)) ``` ``` ## [1] 1 2 ``` ```r # x2 is a sequence of numbers from 1 to 10 (x2 <- seq(from = 1, to = 10)) ``` ``` ## [1] 1 2 3 4 5 6 7 8 9 10 ``` --- ### Vector Recycling If we add `x1` and `x2` together, R will do it, but the result might not be what we expect: ```r (x1 + x2) ``` ``` ## [1] 2 4 4 6 6 8 8 10 10 12 ``` The shorter vector, `x1`, is duplicated five times in order to match the length of the longer vector `x2.` This behavior is called **vector recycling** and happens automatically in R. You need to pay attention if this is what you intended to do. If not, extend the length of the shorter vector manually first, then add them up. Note, if the shorter vector is not a multiple of the longer one, R will print a warning message. --- ### Subsetting vectors: slicing To subset a vector we use the index location of its elements: ```r x <- c("one", "two", "three", "four", "five") ``` ``` # keep the first element x[1] # keep the first through third elements x[c(1, 2, 3)] # long way x[1:3] # shorter x[c(seq(1, 3))] # sequence x[-c(4:5)] # negative indexing (values that you do not want to keep) x[-c(4,5)] # negative indexing x[c(-1,2,3)] # error! do not mix negative and positive subscripts ``` --- ### Subset with a logical vector: conditional subsetting Sometimes, rather than slicing, like we did in the previous example, we want to keep certain values based of a **condition**. This is more similar to a filtering operation (vs. slicing) and it is a 2-step operation: 1. create a logical vector of TRUEs and FALSEs, that identifies for each of the elements in the original vector, which one we want to keep 2. apply that vector to the vector we want to subset --- ### Subset with a logical vector: conditional subsetting Given a vector `x`: ```r x <- c(NA, 10, 3, 5, 8, 1, NA) ``` We want to keep all the non-missing values in `x`. To find them we can use `is.na()`. This function outputs a logical vector of TRUEs and FALSEs. Notice the `!` reverts the output, so we get TRUE for non-missing and FALSE for missing values -- we want to keep the TRUEs: ```r !is.na(x) ``` ``` ## [1] FALSE TRUE TRUE TRUE TRUE TRUE FALSE ``` Then, we put the function into `[]` to apply it to our `x` vector. This says "keep all elements that are TRUE" in this vector: ```r x[!is.na(x)] ``` ``` ## [1] 10 3 5 8 1 ``` --- ### Subset with a logical vector: conditional subsetting This applies to any kind of conditional test. For example, given the same vector `x`: ```r x <- c(NA, 10, 3, 5, 8, 1, NA) ``` We might want to get all even or missing values of `x`. To do so, we first use modular division: ```r x %% 2 == 0 ``` ``` ## [1] NA TRUE FALSE FALSE TRUE FALSE NA ``` Then, we apply it to our vector `x`: ```r x[x %% 2 == 0] ``` ``` ## [1] NA 10 8 NA ``` --- class: inverse, middle # Lists --- ## Lists Lists are another type of vector, but they are not atomic vector. They differ from atomic vectors in two main ways: 1. They **store heterogeneous elements** (vs. all values in an atomic vector must be of the same type) 2. They **are structured differently** and are created with the `list()` function, not with the `c()` function. Notice the output is different than the output from an atomic vector: ```r x <- list(1, 2, 3) x ``` ``` ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ``` --- ## Lists structure List objects are structured as a list of **independent elements**. Use `str()` to see their structure: ```r x <- list(1, 2, 3) str(x) ``` ``` ## List of 3 ## $ : num 1 ## $ : num 2 ## $ : num 3 ``` Here we have a list of length 3, and each of the elements of this list is a numeric atomic vector of length 1. --- ## Lists elements Unlike atomic vectors, lists can contain **multiple data types**, and we can also name each of them: ```r x_named <- list(a = "abc", b = 2, c = c(1, 2, 3)) str(x_named) ``` ``` ## List of 3 ## $ a: chr "abc" ## $ b: num 2 ## $ c: num [1:3] 1 2 3 ``` Here we have a list of length 3, and each of the elements of this list is a different object: we have a character vector of length 1, one numeric vector of length 1, and one numeric vector of length 3. --- ## Nested lists You can also store lists inside a list: **nested list structure**. In this object `z` we have two lists: ```r z <- list(list(1, 2), list(3, 4)) str(z) ``` ``` ## List of 2 ## $ :List of 2 ## ..$ : num 1 ## ..$ : num 2 ## $ :List of 2 ## ..$ : num 3 ## ..$ : num 4 ``` This is often useful when you interact with API to get data from the web (frequently you get this type of nested list as output when you get data from API). --- ## Secret lists: data frames! Notice, we have been using lists extensively in the class. Each column of a data frame is a list: ```r str(gun_deaths) ``` ``` ## spc_tbl_ [100,798 × 10] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ id : num [1:100798] 1 2 3 4 5 6 7 8 9 10 ... ## $ year : num [1:100798] 2012 2012 2012 2012 2012 ... ## $ month : chr [1:100798] "Jan" "Jan" "Jan" "Feb" ... ## $ intent : chr [1:100798] "Suicide" "Suicide" "Suicide" "Suicide" ... ## $ police : num [1:100798] 0 0 0 0 0 0 0 0 0 0 ... ## $ sex : chr [1:100798] "M" "F" "M" "M" ... ## $ age : num [1:100798] 34 21 60 64 31 17 48 41 50 NA ... ## $ race : chr [1:100798] "Asian/Pacific Islander" "White" "White" "White" ... ## $ place : chr [1:100798] "Home" "Street" "Other specified" "Home" ... ## $ education: Factor w/ 4 levels "Less than HS",..: 4 3 4 4 2 1 2 2 3 NA ... ``` The only difference between data frames and actual lists is that the length of each list object in the data frame has to the same (a data frame is rectangular). --- ## Subsetting lists Lists have a more complex structure than vectors, thus subsetting them also requires more attention. .pull-left[ For example, `a` is a list that contains four elements: * a numeric vector * a character vector * a numeric vector * a list object which in turns contains two distinct numeric vectors (notice the space in the middle) ] .pull-right[ <img src="lists-subsetting-a-only.png" width="30%" style="display: block; margin: auto;" /> ] --- ## Subsetting lists <img src="https://r4ds.had.co.nz/diagrams/lists-subsetting.png" width="50%" style="display: block; margin: auto;" /> --- class: inverse, middle # Practice subsetting vectors and lists --- ## Acknowledgments The content of these slides is derived in part from Sabrina Nardin and Benjamin Soltoff’s “Computing for the Social Sciences” course materials, licensed under the CC BY NC 4.0 Creative Commons License. Any errors or oversights are mine alone.'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="slides"><meta itemprop=name content="CFSS: Computing for the Social Sciences"><meta itemprop=description content='<!DOCTYPE html> Data Structures class: center, middle, inverse, title-slide .title[ # Data Structures ] .author[ ### MACSS 30500 University of Chicago ] --- class: inverse, middle # R Base Data Structures <!-- notes: this is a new lecture that focuses on a general review of data structures from the original lecture ("vectors-and-iteration") I kept the vectors and lists here and I need to enlarge this lecture with more data structures I do not think I need all libraries listed there, double check also check this lecture corresponding pages on the syllabus this lecture does not have notes (content > notes) make sure to do that ahead of time to ensure things work! --> --- ### R Base Data Structures R data structures: * Vectors * Matrices * Lists * Data frames * Arrays These data structures can be organized by: - their dimensions (1d, 2d, or nd) - whether they are homogeneous (all contents must be of the same type, like atomic vectors and matrices) or heterogeneous (contents can be of different types, like lists and data frames) Please, review: * Lecture 2 (`introR_lecture`) to define, subset, and manipulate these data structures * Chapter 20 "Vectors" in R for Data Science --- ### R is fundamentally a vector-based program So far, we have been using predominantly data frames, which are very common when working with social science data. However, data frames are not actually the most fundamental type of object in R: **vectors are the ultimate building blocks of objects within R**. A matrix is made of vectors, a list is made of vectors (a list is still a vector in R but not an atomic one), data frames are made by lists, etc. Basically in R either something is a vector, or it&#39;s NULL... --- ### R is fundamentally a vector-based program <img src="https://r4ds.had.co.nz/diagrams/data-structures-overview.png" width="60%" style="display: block; margin: auto;" /> <!-- focus today is on atomic vectors and lists --> --- class: inverse, middle # Atomic vectors --- ### Types of atomic vectors Remember: **All values in an atomic vector must to be of the same type**. **Logical**: you have used it every time you use a conditional test or operation (e.g., when you filter a data frame) ```r logical_vector <- c("TRUE", "TRUE", "FALSE", "TRUE", "NA") ``` **Numeric**: can be integer or double (default) ```r integer_vector <- c("1", "5", "3", "4", "12423") double_vector <- c("4.2", "4", "6", "53.2") ``` **Character**: note you can use single or double quotations, you just need to be consistent ```r character_vector <- c("Scary", "&#39;1,2,3 ready!&#39;", "Halloween", &#39;10/31/2022&#39;) ``` --- ### Scalars In math a scalar is defined as a single real number. R has no concept of a scalar: **in R, a scalar is simply a vector of length 1** ```r # set up a vector x of length 10 (x <- sample(10)) ``` ``` ## [1] 10 6 5 4 1 8 2 7 9 3 ``` ```r # add 100 to x x + c(100, 100, 100, 100, 100, 100, 100, 100, 100, 100) ``` ``` ## [1] 110 106 105 104 101 108 102 107 109 103 ``` ```r # add 100 to x: the R way (vector recycling) x + 100 ``` ``` ## [1] 110 106 105 104 101 108 102 107 109 103 ``` <!-- The second way to add the numbers is more efficient but can also be dangerous...--> --- ### Vector Recycling When two vectors are involved in an operation, **R repeats the elements of the shorter vector to match the length of the longer vector**. This will work for any vector of any length. For example: ```r # x1 is sequence of numbers from 1 to 2 (x1 <- seq(from = 1, to = 2)) ``` ``` ## [1] 1 2 ``` ```r # x2 is a sequence of numbers from 1 to 10 (x2 <- seq(from = 1, to = 10)) ``` ``` ## [1] 1 2 3 4 5 6 7 8 9 10 ``` --- ### Vector Recycling If we add `x1` and `x2` together, R will do it, but the result might not be what we expect: ```r (x1 + x2) ``` ``` ## [1] 2 4 4 6 6 8 8 10 10 12 ``` The shorter vector, `x1`, is duplicated five times in order to match the length of the longer vector `x2.` This behavior is called **vector recycling** and happens automatically in R. You need to pay attention if this is what you intended to do. If not, extend the length of the shorter vector manually first, then add them up. Note, if the shorter vector is not a multiple of the longer one, R will print a warning message. --- ### Subsetting vectors: slicing To subset a vector we use the index location of its elements: ```r x <- c("one", "two", "three", "four", "five") ``` ``` # keep the first element x[1] # keep the first through third elements x[c(1, 2, 3)] # long way x[1:3] # shorter x[c(seq(1, 3))] # sequence x[-c(4:5)] # negative indexing (values that you do not want to keep) x[-c(4,5)] # negative indexing x[c(-1,2,3)] # error! do not mix negative and positive subscripts ``` --- ### Subset with a logical vector: conditional subsetting Sometimes, rather than slicing, like we did in the previous example, we want to keep certain values based of a **condition**. This is more similar to a filtering operation (vs. slicing) and it is a 2-step operation: 1. create a logical vector of TRUEs and FALSEs, that identifies for each of the elements in the original vector, which one we want to keep 2. apply that vector to the vector we want to subset --- ### Subset with a logical vector: conditional subsetting Given a vector `x`: ```r x <- c(NA, 10, 3, 5, 8, 1, NA) ``` We want to keep all the non-missing values in `x`. To find them we can use `is.na()`. This function outputs a logical vector of TRUEs and FALSEs. Notice the `!` reverts the output, so we get TRUE for non-missing and FALSE for missing values -- we want to keep the TRUEs: ```r !is.na(x) ``` ``` ## [1] FALSE TRUE TRUE TRUE TRUE TRUE FALSE ``` Then, we put the function into `[]` to apply it to our `x` vector. This says "keep all elements that are TRUE" in this vector: ```r x[!is.na(x)] ``` ``` ## [1] 10 3 5 8 1 ``` --- ### Subset with a logical vector: conditional subsetting This applies to any kind of conditional test. For example, given the same vector `x`: ```r x <- c(NA, 10, 3, 5, 8, 1, NA) ``` We might want to get all even or missing values of `x`. To do so, we first use modular division: ```r x %% 2 == 0 ``` ``` ## [1] NA TRUE FALSE FALSE TRUE FALSE NA ``` Then, we apply it to our vector `x`: ```r x[x %% 2 == 0] ``` ``` ## [1] NA 10 8 NA ``` --- class: inverse, middle # Lists --- ## Lists Lists are another type of vector, but they are not atomic vector. They differ from atomic vectors in two main ways: 1. They **store heterogeneous elements** (vs. all values in an atomic vector must be of the same type) 2. They **are structured differently** and are created with the `list()` function, not with the `c()` function. Notice the output is different than the output from an atomic vector: ```r x <- list(1, 2, 3) x ``` ``` ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ``` --- ## Lists structure List objects are structured as a list of **independent elements**. Use `str()` to see their structure: ```r x <- list(1, 2, 3) str(x) ``` ``` ## List of 3 ## $ : num 1 ## $ : num 2 ## $ : num 3 ``` Here we have a list of length 3, and each of the elements of this list is a numeric atomic vector of length 1. --- ## Lists elements Unlike atomic vectors, lists can contain **multiple data types**, and we can also name each of them: ```r x_named <- list(a = "abc", b = 2, c = c(1, 2, 3)) str(x_named) ``` ``` ## List of 3 ## $ a: chr "abc" ## $ b: num 2 ## $ c: num [1:3] 1 2 3 ``` Here we have a list of length 3, and each of the elements of this list is a different object: we have a character vector of length 1, one numeric vector of length 1, and one numeric vector of length 3. --- ## Nested lists You can also store lists inside a list: **nested list structure**. In this object `z` we have two lists: ```r z <- list(list(1, 2), list(3, 4)) str(z) ``` ``` ## List of 2 ## $ :List of 2 ## ..$ : num 1 ## ..$ : num 2 ## $ :List of 2 ## ..$ : num 3 ## ..$ : num 4 ``` This is often useful when you interact with API to get data from the web (frequently you get this type of nested list as output when you get data from API). --- ## Secret lists: data frames! Notice, we have been using lists extensively in the class. Each column of a data frame is a list: ```r str(gun_deaths) ``` ``` ## spc_tbl_ [100,798 × 10] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ id : num [1:100798] 1 2 3 4 5 6 7 8 9 10 ... ## $ year : num [1:100798] 2012 2012 2012 2012 2012 ... ## $ month : chr [1:100798] "Jan" "Jan" "Jan" "Feb" ... ## $ intent : chr [1:100798] "Suicide" "Suicide" "Suicide" "Suicide" ... ## $ police : num [1:100798] 0 0 0 0 0 0 0 0 0 0 ... ## $ sex : chr [1:100798] "M" "F" "M" "M" ... ## $ age : num [1:100798] 34 21 60 64 31 17 48 41 50 NA ... ## $ race : chr [1:100798] "Asian/Pacific Islander" "White" "White" "White" ... ## $ place : chr [1:100798] "Home" "Street" "Other specified" "Home" ... ## $ education: Factor w/ 4 levels "Less than HS",..: 4 3 4 4 2 1 2 2 3 NA ... ``` The only difference between data frames and actual lists is that the length of each list object in the data frame has to the same (a data frame is rectangular). --- ## Subsetting lists Lists have a more complex structure than vectors, thus subsetting them also requires more attention. .pull-left[ For example, `a` is a list that contains four elements: * a numeric vector * a character vector * a numeric vector * a list object which in turns contains two distinct numeric vectors (notice the space in the middle) ] .pull-right[ <img src="lists-subsetting-a-only.png" width="30%" style="display: block; margin: auto;" /> ] --- ## Subsetting lists <img src="https://r4ds.had.co.nz/diagrams/lists-subsetting.png" width="50%" style="display: block; margin: auto;" /> --- class: inverse, middle # Practice subsetting vectors and lists --- ## Acknowledgments The content of these slides is derived in part from Sabrina Nardin and Benjamin Soltoff’s “Computing for the Social Sciences” course materials, licensed under the CC BY NC 4.0 Creative Commons License. Any errors or oversights are mine alone.'><meta itemprop=wordCount content="1888"><meta name=twitter:card content="summary"><meta name=twitter:title content="CFSS: Computing for the Social Sciences"><meta name=twitter:description content='<!DOCTYPE html> Data Structures class: center, middle, inverse, title-slide .title[ # Data Structures ] .author[ ### MACSS 30500 University of Chicago ] --- class: inverse, middle # R Base Data Structures <!-- notes: this is a new lecture that focuses on a general review of data structures from the original lecture ("vectors-and-iteration") I kept the vectors and lists here and I need to enlarge this lecture with more data structures I do not think I need all libraries listed there, double check also check this lecture corresponding pages on the syllabus this lecture does not have notes (content > notes) make sure to do that ahead of time to ensure things work! --> --- ### R Base Data Structures R data structures: * Vectors * Matrices * Lists * Data frames * Arrays These data structures can be organized by: - their dimensions (1d, 2d, or nd) - whether they are homogeneous (all contents must be of the same type, like atomic vectors and matrices) or heterogeneous (contents can be of different types, like lists and data frames) Please, review: * Lecture 2 (`introR_lecture`) to define, subset, and manipulate these data structures * Chapter 20 "Vectors" in R for Data Science --- ### R is fundamentally a vector-based program So far, we have been using predominantly data frames, which are very common when working with social science data. However, data frames are not actually the most fundamental type of object in R: **vectors are the ultimate building blocks of objects within R**. A matrix is made of vectors, a list is made of vectors (a list is still a vector in R but not an atomic one), data frames are made by lists, etc. Basically in R either something is a vector, or it&#39;s NULL... --- ### R is fundamentally a vector-based program <img src="https://r4ds.had.co.nz/diagrams/data-structures-overview.png" width="60%" style="display: block; margin: auto;" /> <!-- focus today is on atomic vectors and lists --> --- class: inverse, middle # Atomic vectors --- ### Types of atomic vectors Remember: **All values in an atomic vector must to be of the same type**. **Logical**: you have used it every time you use a conditional test or operation (e.g., when you filter a data frame) ```r logical_vector <- c("TRUE", "TRUE", "FALSE", "TRUE", "NA") ``` **Numeric**: can be integer or double (default) ```r integer_vector <- c("1", "5", "3", "4", "12423") double_vector <- c("4.2", "4", "6", "53.2") ``` **Character**: note you can use single or double quotations, you just need to be consistent ```r character_vector <- c("Scary", "&#39;1,2,3 ready!&#39;", "Halloween", &#39;10/31/2022&#39;) ``` --- ### Scalars In math a scalar is defined as a single real number. R has no concept of a scalar: **in R, a scalar is simply a vector of length 1** ```r # set up a vector x of length 10 (x <- sample(10)) ``` ``` ## [1] 10 6 5 4 1 8 2 7 9 3 ``` ```r # add 100 to x x + c(100, 100, 100, 100, 100, 100, 100, 100, 100, 100) ``` ``` ## [1] 110 106 105 104 101 108 102 107 109 103 ``` ```r # add 100 to x: the R way (vector recycling) x + 100 ``` ``` ## [1] 110 106 105 104 101 108 102 107 109 103 ``` <!-- The second way to add the numbers is more efficient but can also be dangerous...--> --- ### Vector Recycling When two vectors are involved in an operation, **R repeats the elements of the shorter vector to match the length of the longer vector**. This will work for any vector of any length. For example: ```r # x1 is sequence of numbers from 1 to 2 (x1 <- seq(from = 1, to = 2)) ``` ``` ## [1] 1 2 ``` ```r # x2 is a sequence of numbers from 1 to 10 (x2 <- seq(from = 1, to = 10)) ``` ``` ## [1] 1 2 3 4 5 6 7 8 9 10 ``` --- ### Vector Recycling If we add `x1` and `x2` together, R will do it, but the result might not be what we expect: ```r (x1 + x2) ``` ``` ## [1] 2 4 4 6 6 8 8 10 10 12 ``` The shorter vector, `x1`, is duplicated five times in order to match the length of the longer vector `x2.` This behavior is called **vector recycling** and happens automatically in R. You need to pay attention if this is what you intended to do. If not, extend the length of the shorter vector manually first, then add them up. Note, if the shorter vector is not a multiple of the longer one, R will print a warning message. --- ### Subsetting vectors: slicing To subset a vector we use the index location of its elements: ```r x <- c("one", "two", "three", "four", "five") ``` ``` # keep the first element x[1] # keep the first through third elements x[c(1, 2, 3)] # long way x[1:3] # shorter x[c(seq(1, 3))] # sequence x[-c(4:5)] # negative indexing (values that you do not want to keep) x[-c(4,5)] # negative indexing x[c(-1,2,3)] # error! do not mix negative and positive subscripts ``` --- ### Subset with a logical vector: conditional subsetting Sometimes, rather than slicing, like we did in the previous example, we want to keep certain values based of a **condition**. This is more similar to a filtering operation (vs. slicing) and it is a 2-step operation: 1. create a logical vector of TRUEs and FALSEs, that identifies for each of the elements in the original vector, which one we want to keep 2. apply that vector to the vector we want to subset --- ### Subset with a logical vector: conditional subsetting Given a vector `x`: ```r x <- c(NA, 10, 3, 5, 8, 1, NA) ``` We want to keep all the non-missing values in `x`. To find them we can use `is.na()`. This function outputs a logical vector of TRUEs and FALSEs. Notice the `!` reverts the output, so we get TRUE for non-missing and FALSE for missing values -- we want to keep the TRUEs: ```r !is.na(x) ``` ``` ## [1] FALSE TRUE TRUE TRUE TRUE TRUE FALSE ``` Then, we put the function into `[]` to apply it to our `x` vector. This says "keep all elements that are TRUE" in this vector: ```r x[!is.na(x)] ``` ``` ## [1] 10 3 5 8 1 ``` --- ### Subset with a logical vector: conditional subsetting This applies to any kind of conditional test. For example, given the same vector `x`: ```r x <- c(NA, 10, 3, 5, 8, 1, NA) ``` We might want to get all even or missing values of `x`. To do so, we first use modular division: ```r x %% 2 == 0 ``` ``` ## [1] NA TRUE FALSE FALSE TRUE FALSE NA ``` Then, we apply it to our vector `x`: ```r x[x %% 2 == 0] ``` ``` ## [1] NA 10 8 NA ``` --- class: inverse, middle # Lists --- ## Lists Lists are another type of vector, but they are not atomic vector. They differ from atomic vectors in two main ways: 1. They **store heterogeneous elements** (vs. all values in an atomic vector must be of the same type) 2. They **are structured differently** and are created with the `list()` function, not with the `c()` function. Notice the output is different than the output from an atomic vector: ```r x <- list(1, 2, 3) x ``` ``` ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ``` --- ## Lists structure List objects are structured as a list of **independent elements**. Use `str()` to see their structure: ```r x <- list(1, 2, 3) str(x) ``` ``` ## List of 3 ## $ : num 1 ## $ : num 2 ## $ : num 3 ``` Here we have a list of length 3, and each of the elements of this list is a numeric atomic vector of length 1. --- ## Lists elements Unlike atomic vectors, lists can contain **multiple data types**, and we can also name each of them: ```r x_named <- list(a = "abc", b = 2, c = c(1, 2, 3)) str(x_named) ``` ``` ## List of 3 ## $ a: chr "abc" ## $ b: num 2 ## $ c: num [1:3] 1 2 3 ``` Here we have a list of length 3, and each of the elements of this list is a different object: we have a character vector of length 1, one numeric vector of length 1, and one numeric vector of length 3. --- ## Nested lists You can also store lists inside a list: **nested list structure**. In this object `z` we have two lists: ```r z <- list(list(1, 2), list(3, 4)) str(z) ``` ``` ## List of 2 ## $ :List of 2 ## ..$ : num 1 ## ..$ : num 2 ## $ :List of 2 ## ..$ : num 3 ## ..$ : num 4 ``` This is often useful when you interact with API to get data from the web (frequently you get this type of nested list as output when you get data from API). --- ## Secret lists: data frames! Notice, we have been using lists extensively in the class. Each column of a data frame is a list: ```r str(gun_deaths) ``` ``` ## spc_tbl_ [100,798 × 10] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ id : num [1:100798] 1 2 3 4 5 6 7 8 9 10 ... ## $ year : num [1:100798] 2012 2012 2012 2012 2012 ... ## $ month : chr [1:100798] "Jan" "Jan" "Jan" "Feb" ... ## $ intent : chr [1:100798] "Suicide" "Suicide" "Suicide" "Suicide" ... ## $ police : num [1:100798] 0 0 0 0 0 0 0 0 0 0 ... ## $ sex : chr [1:100798] "M" "F" "M" "M" ... ## $ age : num [1:100798] 34 21 60 64 31 17 48 41 50 NA ... ## $ race : chr [1:100798] "Asian/Pacific Islander" "White" "White" "White" ... ## $ place : chr [1:100798] "Home" "Street" "Other specified" "Home" ... ## $ education: Factor w/ 4 levels "Less than HS",..: 4 3 4 4 2 1 2 2 3 NA ... ``` The only difference between data frames and actual lists is that the length of each list object in the data frame has to the same (a data frame is rectangular). --- ## Subsetting lists Lists have a more complex structure than vectors, thus subsetting them also requires more attention. .pull-left[ For example, `a` is a list that contains four elements: * a numeric vector * a character vector * a numeric vector * a list object which in turns contains two distinct numeric vectors (notice the space in the middle) ] .pull-right[ <img src="lists-subsetting-a-only.png" width="30%" style="display: block; margin: auto;" /> ] --- ## Subsetting lists <img src="https://r4ds.had.co.nz/diagrams/lists-subsetting.png" width="50%" style="display: block; margin: auto;" /> --- class: inverse, middle # Practice subsetting vectors and lists --- ## Acknowledgments The content of these slides is derived in part from Sabrina Nardin and Benjamin Soltoff’s “Computing for the Social Sciences” course materials, licensed under the CC BY NC 4.0 Creative Commons License. Any errors or oversights are mine alone.'><link rel=preload href=/scss/main.min.2bf6e9109f6f32347205312f445c5d7dea681b9fd1802a211b5786faf06a9b77.css as=style integrity="sha256-K/bpEJ9vMjRyBTEvRFxdfepoG5/RgCohG1eG+vBqm3c=" crossorigin=anonymous><link href=/scss/main.min.2bf6e9109f6f32347205312f445c5d7dea681b9fd1802a211b5786faf06a9b77.css rel=stylesheet integrity="sha256-K/bpEJ9vMjRyBTEvRFxdfepoG5/RgCohG1eG+vBqm3c=" crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script></head><body class=td-page><header><nav class="td-navbar js-navbar-scroll" data-bs-theme=dark><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>CFSS: Computing for the Social Sciences</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class=nav-link href=/><span>Home</span></a></li><li class=nav-item><a class=nav-link href=/syllabus/><span>Syllabus</span></a></li><li class=nav-item><a class=nav-link href=/schedule/><span>Schedule</span></a></li><li class=nav-item><a class=nav-link href=/assignments/><span>Assignments</span></a></li></ul></div><div class="d-none d-lg-block"></div></div></nav></header><div class="container-fluid td-default td-outer"><main role=main class=td-main><!doctype html><html lang xml:lang><head><title>Data Structures</title><meta charset=utf-8><meta name=author content="MACSS 30500   University of Chicago"><script src=index_files/header-attrs/header-attrs.js></script><link href=index_files/panelset/panelset.css rel=stylesheet><script src=index_files/panelset/panelset.js></script><link rel=stylesheet href=xaringan-themer.css type=text/css></head><body><textarea id=source>
class: center, middle, inverse, title-slide

.title[
# Data Structures
]
.author[
### MACSS 30500 <br /> University of Chicago
]

---






class: inverse, middle

# R Base Data Structures

&lt;!-- notes:
this is a new lecture that focuses on a general review of data structures
from the original lecture ("vectors-and-iteration") I kept the vectors and lists here 
and I need to enlarge this lecture with more data structures
I do not think I need all libraries listed there, double check

also check this lecture corresponding pages on the syllabus 
this lecture does not have notes (content &gt; notes)
make sure to do that ahead of time to ensure things work!
--&gt;

---

### R Base Data Structures

R data structures:
* Vectors
* Matrices
* Lists
* Data frames
* Arrays

These data structures can be organized by:
- their dimensions (1d, 2d, or nd)
- whether they are homogeneous (all contents must be of the same type, like atomic vectors and matrices) or heterogeneous (contents can be of different types, like lists and data frames)

Please, review:
* Lecture 2 (`introR_lecture`) to define, subset, and manipulate these data structures
* Chapter 20 "Vectors" in R for Data Science

---

### R is fundamentally a vector-based program

So far, we have been using predominantly data frames, which are very common when working with social science data. 

However, data frames are not actually the most fundamental type of object in R: **vectors are the ultimate building blocks of objects within R**.

A matrix is made of vectors, a list is made of vectors (a list is still a vector in R but not an atomic one), data frames are made by lists, etc.

Basically in R either something is a vector, or it's NULL...

---

### R is fundamentally a vector-based program

&lt;img src="https://r4ds.had.co.nz/diagrams/data-structures-overview.png" width="60%" style="display: block; margin: auto;" /&gt;

&lt;!-- focus today is on atomic vectors and lists --&gt;

---

class: inverse, middle

# Atomic vectors 

---

### Types of atomic vectors

Remember: **All values in an atomic vector must to be of the same type**.

**Logical**: you have used it every time you use a conditional test or operation (e.g., when you filter a data frame)

```r
logical_vector &lt;- c("TRUE", "TRUE", "FALSE", "TRUE", "NA")
```

**Numeric**: can be integer or double (default)

```r
integer_vector &lt;- c("1", "5", "3", "4", "12423")
double_vector &lt;- c("4.2", "4", "6", "53.2")
```

**Character**: note you can use single or double quotations, you just need to be consistent

```r
character_vector &lt;- c("Scary", "'1,2,3 ready!'", "Halloween", '10/31/2022')
```

---

### Scalars

In math a scalar is defined as a single real number. R has no concept of a scalar: **in R, a scalar is simply a vector of length 1**


```r
# set up a vector x of length 10
(x &lt;- sample(10))
```

```
##  [1] 10  6  5  4  1  8  2  7  9  3
```

```r
# add 100 to x
x + c(100, 100, 100, 100, 100, 100, 100, 100, 100, 100)
```

```
##  [1] 110 106 105 104 101 108 102 107 109 103
```

```r
# add 100 to x: the R way (vector recycling)
x + 100
```

```
##  [1] 110 106 105 104 101 108 102 107 109 103
```

&lt;!-- The second way to add the numbers is more efficient but can also be dangerous...--&gt;

---

### Vector Recycling

When two vectors are involved in an operation, **R repeats the elements of the shorter vector to match the length of the longer vector**.

This will work for any vector of any length. For example:

```r
# x1 is sequence of numbers from 1 to 2
(x1 &lt;- seq(from = 1, to = 2))
```

```
## [1] 1 2
```

```r
# x2 is a sequence of numbers from 1 to 10
(x2 &lt;- seq(from = 1, to = 10))
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

---

### Vector Recycling

If we add `x1` and `x2` together, R will do it, but the result might not be what we expect:

```r
(x1 + x2)
```

```
##  [1]  2  4  4  6  6  8  8 10 10 12
```

The shorter vector, `x1`, is duplicated five times in order to match the length of the longer vector `x2.` 

This behavior is called **vector recycling** and happens automatically in R. You need to pay attention if this is what you intended to do. If not, extend the length of the shorter vector manually first, then add them up.

Note, if the shorter vector is not a multiple of the longer one, R will print a warning message.

---

### Subsetting vectors: slicing

To subset a vector we use the index location of its elements:


```r
x &lt;- c("one", "two", "three", "four", "five")
```

```
# keep the first element
x[1]

# keep the first through third elements
x[c(1, 2, 3)]   # long way
x[1:3]          # shorter
x[c(seq(1, 3))] # sequence 
x[-c(4:5)]      # negative indexing (values that you do not want to keep)
x[-c(4,5)]      # negative indexing

x[c(-1,2,3)]   # error! do not mix negative and positive subscripts
```

---

### Subset with a logical vector: conditional subsetting

Sometimes, rather than slicing, like we did in the previous example, we want to keep certain values based of a **condition**. 

This is more similar to a filtering operation (vs. slicing) and it is a 2-step operation:
1. create a logical vector of TRUEs and FALSEs, that identifies for each of the elements in the original vector, which one we want to keep

2. apply that vector to the vector we want to subset 

---

### Subset with a logical vector: conditional subsetting

Given a vector `x`:

```r
x &lt;- c(NA, 10, 3, 5, 8, 1, NA)
```

We want to keep all the non-missing values in `x`. To find them we can use `is.na()`. This function outputs a logical vector of TRUEs and FALSEs.
Notice the `!` reverts the output, so we get TRUE for non-missing and FALSE for missing values -- we want to keep the TRUEs:

```r
!is.na(x)
```

```
## [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE
```

Then, we put the function into `[]` to apply it to our `x` vector. This says "keep all elements that are TRUE" in this vector:

```r
x[!is.na(x)]
```

```
## [1] 10  3  5  8  1
```

---

### Subset with a logical vector: conditional subsetting

This applies to any kind of conditional test. For example, given the same vector `x`:

```r
x &lt;- c(NA, 10, 3, 5, 8, 1, NA)
```

We might want to get all even or missing values of `x`. To do so, we first use modular division: 

```r
x %% 2 == 0 
```

```
## [1]    NA  TRUE FALSE FALSE  TRUE FALSE    NA
```

Then, we apply it to our vector `x`:

```r
x[x %% 2 == 0]
```

```
## [1] NA 10  8 NA
```

---

class: inverse, middle

# Lists

---

## Lists

Lists are another type of vector, but they are not atomic vector. They differ from atomic vectors in two main ways:

1. They **store heterogeneous elements** (vs. all values in an atomic vector must be of the same type)
2. They **are structured differently** and are created with the `list()` function, not with the `c()` function. Notice the output is different than the output from an atomic vector:

```r
x &lt;- list(1, 2, 3)
x
```

```
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3
```

---

## Lists structure

List objects are structured as a list of **independent elements**. Use `str()` to see their structure: 

```r
x &lt;- list(1, 2, 3)
str(x)
```

```
## List of 3
##  $ : num 1
##  $ : num 2
##  $ : num 3
```

Here we have a list of length 3, and each of the elements of this list is a numeric atomic vector of length 1.

---

## Lists elements

Unlike atomic vectors, lists can contain **multiple data types**, and we can also name each of them:

```r
x_named &lt;- list(a = "abc", b = 2, c = c(1, 2, 3))
str(x_named)
```

```
## List of 3
##  $ a: chr "abc"
##  $ b: num 2
##  $ c: num [1:3] 1 2 3
```
Here we have a list of length 3, and each of the elements of this list is a different object: we have a character vector of length 1, one numeric vector of length 1, and one numeric vector of length 3. 

---

## Nested lists

You can also store lists inside a list: **nested list structure**. 

In this object `z` we have two lists:

```r
z &lt;- list(list(1, 2), list(3, 4))
str(z)
```

```
## List of 2
##  $ :List of 2
##   ..$ : num 1
##   ..$ : num 2
##  $ :List of 2
##   ..$ : num 3
##   ..$ : num 4
```

This is often useful when you interact with API to get data from the web (frequently you get this type of nested list as output when you get data from API).

---

## Secret lists: data frames!

Notice, we have been using lists extensively in the class. Each column of a data frame is a list: 

```r
str(gun_deaths)
```

```
## spc_tbl_ [100,798 × 10] (S3: spec_tbl_df/tbl_df/tbl/data.frame)
##  $ id       : num [1:100798] 1 2 3 4 5 6 7 8 9 10 ...
##  $ year     : num [1:100798] 2012 2012 2012 2012 2012 ...
##  $ month    : chr [1:100798] "Jan" "Jan" "Jan" "Feb" ...
##  $ intent   : chr [1:100798] "Suicide" "Suicide" "Suicide" "Suicide" ...
##  $ police   : num [1:100798] 0 0 0 0 0 0 0 0 0 0 ...
##  $ sex      : chr [1:100798] "M" "F" "M" "M" ...
##  $ age      : num [1:100798] 34 21 60 64 31 17 48 41 50 NA ...
##  $ race     : chr [1:100798] "Asian/Pacific Islander" "White" "White" "White" ...
##  $ place    : chr [1:100798] "Home" "Street" "Other specified" "Home" ...
##  $ education: Factor w/ 4 levels "Less than HS",..: 4 3 4 4 2 1 2 2 3 NA ...
```

The only difference between data frames and actual lists is that the length of each list object in the data frame has to the same (a data frame is rectangular).

---

## Subsetting lists

Lists have a more complex structure than vectors, thus subsetting them also requires more attention.

.pull-left[

For example, `a` is a list that contains four elements: 
* a numeric vector
* a character vector
* a numeric vector
* a list object which in turns contains two distinct numeric vectors (notice the space in the middle)

]

.pull-right[

&lt;img src="lists-subsetting-a-only.png" width="30%" style="display: block; margin: auto;" /&gt;

]

---

## Subsetting lists

&lt;img src="https://r4ds.had.co.nz/diagrams/lists-subsetting.png" width="50%" style="display: block; margin: auto;" /&gt;

---

class: inverse, middle

# Practice subsetting vectors and lists

---

## Acknowledgments 

The content of these slides is derived in part from Sabrina Nardin and Benjamin Soltoff’s “Computing for the Social Sciences” course materials, licensed under the CC BY NC 4.0 Creative Commons License. Any errors or oversights are mine alone.
    </textarea><style data-target=print-only>@media screen{.remark-slide-container{display:block}.remark-slide-scaler{box-shadow:none}}</style><script src=https://remarkjs.com/downloads/remark-latest.min.js></script><script>var slideshow=remark.create({highlightStyle:"magula",highlightLines:!0,highlightLanguage:"r",ratio:"16:9",countIncrementalSlides:!1});window.HTMLWidgets&&slideshow.on("afterShowSlide",function(){window.dispatchEvent(new Event("resize"))}),function(e){var t=e.createElement("style"),n=e.querySelector(".remark-slide-scaler");if(!n)return;t.type="text/css",t.innerHTML="@page {size: "+n.style.width+" "+n.style.height+"; }",e.head.appendChild(t)}(document),function(e){if(s=e.getElementsByClassName("remark-slides-area"),!s)return;for(var n,s,o,i=slideshow.getSlides(),a=s[0].children,t=1;t<i.length;t++)o=i[t],(o.properties.continued==="true"||o.properties.count==="false")&&(a[t-1].className+=" has-continuation");n=e.createElement("style"),n.type="text/css",n.innerHTML="@media print { .has-continuation { display: none; } }",e.head.appendChild(n)}(document),function(){var e=!1;slideshow.on("beforeShowSlide",function(){if(e)return;for(var n,o=document.styleSheets,s=0;s<o.length;s++){if(n=o[s].ownerNode,n.dataset.target!=="print-only")continue;n.parentNode.removeChild(n)}e=!0})}(),function(e){let t={};e.querySelectorAll(".remark-help-content table tr").forEach(e=>{const n=e.querySelector("td:nth-child(2)").innerText;e.querySelectorAll("td:first-child .key").forEach(e=>{const s=e.innerText;/^[a-z]$/.test(s)&&(t[s]=n)})}),e.body.setAttribute("data-at-shortcutkeys",JSON.stringify(t))}(document),function(){"use strict";var e,n,s,o,i,t=document.querySelectorAll(".remark-slides-area .remark-slide-container script");if(!t.length)return;for(e=0;e<t.length;e++){s=document.createElement("script"),i=document.createTextNode(t[e].textContent),s.appendChild(i);for(o=t[e].attributes,n=0;n<o.length;n++)s.setAttribute(o[n].name,o[n].value);t[e].parentElement.replaceChild(s,t[e])}}(),function(){for(var t=document.getElementsByTagName("a"),e=0;e<t.length;e++)/^(https?:)?\/\//.test(t[e].getAttribute("href"))&&(t[e].target="_blank")}(),function(e){const s=e.querySelectorAll(".remark-code-line-highlighted"),t=[],n=function(e,t=0){if(t>1)return null;const s=e.parentElement;return s.tagName==="PRE"?s:n(s,++t)};for(let o of s){let e=n(o);e&&!t.includes(e)&&t.push(e)}t.forEach(e=>e.classList.add("remark-code-has-line-highlighted"))}(document)</script><script>slideshow._releaseMath=function(e){var t,n,s,o=e.getElementsByTagName("code");for(s=0;s<o.length;){if(t=o[s],t.parentNode.tagName!=="PRE"&&t.childElementCount===0&&(n=t.textContent,/^\\\((.|\s)+\\\)$/.test(n)||/^\\\[(.|\s)+\\\]$/.test(n)||/^\$\$(.|\s)+\$\$$/.test(n)||/^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(n))){t.outerHTML=t.innerHTML;continue}s++}},slideshow._releaseMath(document)</script><script>(function(){var e=document.createElement("script");e.type="text/javascript",e.src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML",location.protocol!=="file:"&&/^https?:/.test(e.src)&&(e.src=e.src.replace(/^https?:/,"")),document.getElementsByTagName("head")[0].appendChild(e)})()</script></body></html></main><!doctype html><html><head><meta charset=utf-8><meta http-equiv=Content-Style-Type content="text/css"><title></title><meta name=Generator content="Cocoa HTML Writer"><meta name=CocoaVersion content="2299.7"><style type=text/css>p.p1{margin:0px;font:12px Times;-webkit-text-stroke:#000000}p.p2{margin:0px 0px 12px;font:12px Times;color:#0000e9;-webkit-text-stroke:#0000e9}li.li3{margin:0px;font:12px Times;-webkit-text-stroke:#000000;min-height:14px}span.s1{font-kerning:none}span.s2{font:10px Times;font-kerning:none}span.s3{text-decoration:underline;font-kerning:none}ul.ul1{list-style-type:disc}</style></head><body><p class=p1><span class=s1></span></p><p class=p1><span class=s1></span></p><p class=p1><span class=s1></span></p><p class=p1><span class=s1></span><span class=s2>© 2025 Jean Clipperton (materials adapted from Benjamin Soltoff and Sabrina Nardin) All Rights Reserved</span><span class=s1> <span class=Apple-converted-space> </span></span></p><p class=p1><span class=s1></span></p></body></html></div><script src=/js/main.min.8c87303b31e50afa09a774582c268712d6bb31cd6df1cdcb4573f32abeab7551.js integrity="sha256-jIcwOzHlCvoJp3RYLCaHEta7Mc1t8c3LRXPzKr6rdVE=" crossorigin=anonymous></script><script defer src=/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js integrity="sha256-c0eKfUgHaYrtfjVesj+YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script></body></html>